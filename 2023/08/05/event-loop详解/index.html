<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Event Loop详解 | 杜世宏 Blog</title>
    <meta name="generator" content="VuePress 1.9.10">
    <script>var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?c18f0390072d97e3a5e6ce62efda4953";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
          })();        
        </script>                
      </script>
    <meta name="description" content="

lastUpdated: 2023-8-05

前言
Event Loop即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。

为啥要弄懂Event Loop
是要增加自己技术的深度，也就是懂得JavaScript的运行机制。

现在在前端领域各种技术层出不穷，掌握底层原理，可以让自己以不变， ...">
    
    <link rel="preload" href="/my-blog/assets/css/0.styles.1f457cd2.css" as="style"><link rel="preload" href="/my-blog/assets/js/app.6d65ba20.js" as="script"><link rel="preload" href="/my-blog/assets/js/4.83dd6824.js" as="script"><link rel="preload" href="/my-blog/assets/js/1.f69694c8.js" as="script"><link rel="preload" href="/my-blog/assets/js/40.09d36728.js" as="script"><link rel="prefetch" href="/my-blog/assets/js/11.66230eee.js"><link rel="prefetch" href="/my-blog/assets/js/12.6b27ff46.js"><link rel="prefetch" href="/my-blog/assets/js/13.ccdc9817.js"><link rel="prefetch" href="/my-blog/assets/js/14.8b96a736.js"><link rel="prefetch" href="/my-blog/assets/js/15.66e987c0.js"><link rel="prefetch" href="/my-blog/assets/js/16.5870cbc0.js"><link rel="prefetch" href="/my-blog/assets/js/17.6b057015.js"><link rel="prefetch" href="/my-blog/assets/js/18.f39d7c31.js"><link rel="prefetch" href="/my-blog/assets/js/19.93033008.js"><link rel="prefetch" href="/my-blog/assets/js/2.26e78d20.js"><link rel="prefetch" href="/my-blog/assets/js/20.892f9734.js"><link rel="prefetch" href="/my-blog/assets/js/21.0d80a05b.js"><link rel="prefetch" href="/my-blog/assets/js/22.f7922a3c.js"><link rel="prefetch" href="/my-blog/assets/js/23.586cee56.js"><link rel="prefetch" href="/my-blog/assets/js/24.f5973030.js"><link rel="prefetch" href="/my-blog/assets/js/25.c84156b2.js"><link rel="prefetch" href="/my-blog/assets/js/26.9598278a.js"><link rel="prefetch" href="/my-blog/assets/js/27.f338630b.js"><link rel="prefetch" href="/my-blog/assets/js/28.2fdbc978.js"><link rel="prefetch" href="/my-blog/assets/js/29.739b3702.js"><link rel="prefetch" href="/my-blog/assets/js/3.d91254c7.js"><link rel="prefetch" href="/my-blog/assets/js/30.dc34c6d2.js"><link rel="prefetch" href="/my-blog/assets/js/31.4264e31f.js"><link rel="prefetch" href="/my-blog/assets/js/32.7d1bee10.js"><link rel="prefetch" href="/my-blog/assets/js/33.63509a14.js"><link rel="prefetch" href="/my-blog/assets/js/34.a96a29d6.js"><link rel="prefetch" href="/my-blog/assets/js/35.f811c900.js"><link rel="prefetch" href="/my-blog/assets/js/36.a6b64119.js"><link rel="prefetch" href="/my-blog/assets/js/37.9cc564e6.js"><link rel="prefetch" href="/my-blog/assets/js/38.24be3058.js"><link rel="prefetch" href="/my-blog/assets/js/39.69402f71.js"><link rel="prefetch" href="/my-blog/assets/js/41.583c4884.js"><link rel="prefetch" href="/my-blog/assets/js/42.fac7a638.js"><link rel="prefetch" href="/my-blog/assets/js/43.961e717b.js"><link rel="prefetch" href="/my-blog/assets/js/44.c5094f42.js"><link rel="prefetch" href="/my-blog/assets/js/45.305f6e0c.js"><link rel="prefetch" href="/my-blog/assets/js/46.b4258653.js"><link rel="prefetch" href="/my-blog/assets/js/5.f91b4a3f.js"><link rel="prefetch" href="/my-blog/assets/js/6.21b0e8b0.js"><link rel="prefetch" href="/my-blog/assets/js/7.6a8c089f.js"><link rel="prefetch" href="/my-blog/assets/js/8.2a1b1738.js"><link rel="prefetch" href="/my-blog/assets/js/vuejs-paginate.36ad9325.js">
    <link rel="stylesheet" href="/my-blog/assets/css/0.styles.1f457cd2.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/my-blog/" class="nav-link home-link">杜世宏 Blog </a> <div class="pv-wrap" style="margin-left:15px;display:flex;align-items: center;"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-eye" style="width:14px;height:14px;vertical-align:middle;"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg> <span style="vertical-align:middle;font-size:14px;margin-left:3px;"></span></div></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/my-blog/Introduction.html" class="nav-link">Introduction</a></li><li class="nav-item"><a href="https://dsh225.github.io/past-blog/" target="_blank" rel="noopener noreferrer" class="nav-link external">PastBlog</a></li><li class="nav-item"><a href="/my-blog/" class="nav-link">Blog</a></li><li class="nav-item"><a href="/my-blog/tag/" class="nav-link">Tags</a></li><li class="nav-item"><a href="https://github.com/dsh225" target="_blank" rel="noopener noreferrer" class="nav-link external">GitHub</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/my-blog/" class="nav-link mobile-home-link">杜世宏 Blog </a> <div class="pv-wrap" style="margin-left: 15px;flex: 1;align-items: center;display: flex;"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-eye" style="width:14px;height:14px;vertical-align:middle;"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg> <span style="vertical-align:middle;font-size:14px;margin-left:3px;"></span></div> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/my-blog/Introduction.html" class="nav-link">Introduction</a></li><li class="mobile-nav-item"><a href="https://dsh225.github.io/past-blog/" target="_blank" rel="noopener noreferrer" class="nav-link external">PastBlog</a></li><li class="mobile-nav-item"><a href="/my-blog/" class="nav-link">Blog</a></li><li class="mobile-nav-item"><a href="/my-blog/tag/" class="nav-link">Tags</a></li><li class="mobile-nav-item"><a href="https://github.com/dsh225" target="_blank" rel="noopener noreferrer" class="nav-link external">GitHub</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><div class="vuepress-blog-theme-content"><div class="pv-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-eye" style="width:14px;height:14px;vertical-align:middle;"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg> <span style="vertical-align: middle;\n  font-size: 14px;"></span></div> <div class="content__default"><h1 id="event-loop详解"><a href="#event-loop详解" class="header-anchor">#</a> Event Loop详解</h1> <p><strong>lastUpdated: 2023-8-05</strong></p> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>Event Loop即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。</p> <h2 id="为啥要弄懂event-loop"><a href="#为啥要弄懂event-loop" class="header-anchor">#</a> 为啥要弄懂Event Loop</h2> <ul><li><p>是要增加自己技术的深度，也就是懂得JavaScript的运行机制。</p></li> <li><p>现在在前端领域各种技术层出不穷，掌握底层原理，可以让自己以不变，应万变。</p></li> <li><p>应对各大互联网公司的面试，懂其原理，题目任其发挥。</p></li></ul> <h2 id="栈、队列的基本概念"><a href="#栈、队列的基本概念" class="header-anchor">#</a> 栈、队列的基本概念</h2> <h3 id="栈-stack"><a href="#栈-stack" class="header-anchor">#</a> 栈（Stack）</h3> <p>栈在计算机科学中是限定仅在表尾进行插入或删除操作的线性表。 栈是一种数据结构，它按照后进先出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据。
栈是只能在某一端插入和删除的特殊线性表。</p> <h3 id="队列-queue"><a href="#队列-queue" class="header-anchor">#</a> 队列（Queue）</h3> <p>特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。
进行插入操作的端称为队尾，进行删除操作的端称为队头。 队列中没有元素时，称为空队列。
队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）</p> <h2 id="event-loop"><a href="#event-loop" class="header-anchor">#</a> Event Loop</h2> <p>在JavaScript中，任务被分为两种，一种宏任务（MacroTask）也叫Task，一种叫微任务（MicroTask）。</p> <h3 id="宏任务"><a href="#宏任务" class="header-anchor">#</a> （宏任务）</h3> <ul><li>script全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。</li></ul> <h3 id="微任务"><a href="#微任务" class="header-anchor">#</a> （微任务）</h3> <ul><li>Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver（具体使用方式查看这里）</li></ul> <h2 id="浏览器中的event-loop"><a href="#浏览器中的event-loop" class="header-anchor">#</a> 浏览器中的Event Loop</h2> <p>Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。</p> <h3 id="js调用栈"><a href="#js调用栈" class="header-anchor">#</a> JS调用栈</h3> <p>JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。</p> <h3 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="header-anchor">#</a> 同步任务和异步任务</h3> <p>Javascript单线程任务被分为同步任务和异步任务，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。
任务队列Task Queue，即队列，是一种先进先出的一种数据结构。</p> <h3 id="事件循环的进程模型"><a href="#事件循环的进程模型" class="header-anchor">#</a> 事件循环的进程模型</h3> <ul><li>选择当前要执行的任务队列，选择任务队列中最先进入的任务，如果任务队列为空即null，则执行跳转*到微任务（MicroTask）的执行步骤。</li> <li>将事件循环中的任务设置为已选择任务。</li> <li>执行任务。</li> <li>将事件循环中当前运行任务设置为null。</li> <li>将已经运行完成的任务从任务队列中删除。</li> <li>microtasks步骤：进入microtask检查点。</li> <li>更新界面渲染。</li> <li>返回第一步。</li></ul> <h3 id="执行进入microtask检查点时-用户代理会执行以下步骤"><a href="#执行进入microtask检查点时-用户代理会执行以下步骤" class="header-anchor">#</a> 执行进入microtask检查点时，用户代理会执行以下步骤：</h3> <ul><li>设置microtask检查点标志为true。</li> <li>当事件循环microtask执行不为空时：选择一个最先进入的microtask队列的microtask，将事件循环的microtask设置为已选择的microtask，运行microtask，将已经执行完成的microtask为null，移出microtask中的microtask。</li> <li>清理IndexDB事务</li> <li>设置进入microtask检查点的标志为false。
上述可能不太好理解，下图是我做的一张图片。</li></ul> <p>执行栈在执行完同步任务后，查看执行栈是否为空，如果执行栈为空，就会去检查微任务(microTask)队列是否为空，如果为空的话，就执行Task（宏任务），否则就一次性执行完所有微任务。
每次单个宏任务执行完毕后，检查微任务(microTask)队列是否为空，如果不为空的话，会按照先入先出的规则全部执行完微任务(microTask)后，设置微任务(microTask)队列为null，然后再执行宏任务，如此循环。</p> <h2 id="举个例子"><a href="#举个例子" class="header-anchor">#</a> 举个例子</h2> <div class="language-Javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>首先我们划分几个分类：</p> <h3 id="第一次执行"><a href="#第一次执行" class="header-anchor">#</a> 第一次执行：</h3> <div class="language-Javascript extra-class"><pre class="language-javascript"><code>Tasks：run script、 setTimeout callback
Microtasks：Promise then	
<span class="token constant">JS</span> <span class="token literal-property property">stack</span><span class="token operator">:</span> script	
<span class="token literal-property property">Log</span><span class="token operator">:</span> script start、script end。
</code></pre></div><p>执行同步代码，将宏任务（Tasks）和微任务(Microtasks)划分到各自队列中。</p> <h3 id="第二次执行"><a href="#第二次执行" class="header-anchor">#</a> 第二次执行：</h3> <div class="language-Javascript extra-class"><pre class="language-javascript"><code>Tasks：run script、 setTimeout callback
Microtasks：Promise2 then	
<span class="token constant">JS</span> <span class="token literal-property property">stack</span><span class="token operator">:</span> Promise2 callback	
<span class="token literal-property property">Log</span><span class="token operator">:</span> script start、script end、promise1、promise2
</code></pre></div><p>执行宏任务后，检测到微任务(Microtasks)队列中不为空，执行Promise1，执行完成Promise1后，调用Promise2.then，放入微任务(Microtasks)队列中，再执行Promise2.then。</p> <h3 id="第三次执行"><a href="#第三次执行" class="header-anchor">#</a> 第三次执行：</h3> <div class="language-Javascript extra-class"><pre class="language-javascript"><code>Tasks：setTimeout callback
Microtasks：	
<span class="token constant">JS</span> <span class="token literal-property property">stack</span><span class="token operator">:</span> setTimeout callback
<span class="token literal-property property">Log</span><span class="token operator">:</span> script start、script end、promise1、promise2、setTimeout

</code></pre></div><p>当微任务(Microtasks)队列中为空时，执行宏任务（Tasks），执行setTimeout callback，打印日志。</p> <h3 id="第四次执行"><a href="#第四次执行" class="header-anchor">#</a> 第四次执行：</h3> <div class="language-Javascript extra-class"><pre class="language-javascript"><code>Tasks：setTimeout callback
Microtasks：	
<span class="token constant">JS</span> <span class="token literal-property property">stack</span><span class="token operator">:</span> 
<span class="token literal-property property">Log</span><span class="token operator">:</span> script start、script end、promise1、promise2、setTimeout
</code></pre></div><p>清空Tasks队列和JS stack。
以上执行帧动画可以查看<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener noreferrer">Tasks, microtasks, queues and schedules<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
或许这张图也更好理解些。</p> <h2 id="再举个例子"><a href="#再举个例子" class="header-anchor">#</a> 再举个例子</h2> <div class="language-Javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">await</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async1 end'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async2 end'</span><span class="token punctuation">)</span> 
<span class="token punctuation">}</span>
<span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Promise'</span><span class="token punctuation">)</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span>
</code></pre></div><p>这里需要先理解async/await。
async/await 在底层转换成了 promise 和 then 回调函数。
也就是说，这是 promise 的语法糖。
每次我们使用 await, 解释器都创建一个 promise 对象，然后把剩下的 async 函数中的操作放到 then 回调函数中。
async/await 的实现，离不开 Promise。从字面意思来理解，async 是“异步”的简写，而 await 是 async wait 的简写可以认为是等待异步方法执行完成。</p> <h3 id="关于73以下版本和73版本的区别"><a href="#关于73以下版本和73版本的区别" class="header-anchor">#</a> 关于73以下版本和73版本的区别</h3> <p>在老版本版本以下，先执行promise1和promise2，再执行async1。
在73版本，先执行async1再执行promise1和promise2。
主要原因是因为在谷歌(金丝雀)73版本中更改了规范，如下图所示：</p> <p>区别在于RESOLVE(thenable)和之间的区别Promise.resolve(thenable)。</p> <h3 id="在老版本中"><a href="#在老版本中" class="header-anchor">#</a> 在老版本中</h3> <p>首先，传递给 await 的值被包裹在一个 Promise 中。然后，处理程序附加到这个包装的 Promise，以便在 Promise 变为 fulfilled 后恢复该函数，并且暂停执行异步函数，一旦 promise 变为 fulfilled，恢复异步函数的执行。
每个 await 引擎必须创建两个额外的 Promise（即使右侧已经是一个 Promise）并且它需要至少三个 microtask 队列 ticks（tick为系统的相对时间单位，也被称为系统的时基，来源于定时器的周期性中断（输出脉冲），一次中断表示一个tick，也被称做一个“时钟滴答”、时标。）。</p> <h3 id="引用贺老师知乎上的一个例子"><a href="#引用贺老师知乎上的一个例子" class="header-anchor">#</a> 引用贺老师知乎上的一个例子</h3> <div class="language-Javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">await</span> p
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'ok'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

简化理解为：

<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token constant">RESOLVE</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'ok'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>如果 RESOLVE(p) 对于 p 为 promise 直接返回 p 的话，那么 p的 then 方法就会被马上调用，其回调就立即进入 job 队列。</li> <li>而如果 RESOLVE(p) 严格按照标准，应该是产生一个新的 promise，尽管该 promise确定会 resolve 为 p，但这个过程本身是异步的，也就是现在进入 job 队列的是新 promise的 resolve过程，所以该 promise 的 then 不会被立即调用，而要等到当前 job 队列执行到前述 resolve 过程才会被调用，然后其回调（也就是继续 await 之后的语句）才加入 job 队列，所以时序上就晚了。</li></ul> <h3 id="谷歌-金丝雀-73版本中"><a href="#谷歌-金丝雀-73版本中" class="header-anchor">#</a> 谷歌（金丝雀）73版本中</h3> <ul><li>使用对PromiseResolve的调用来更改await的语义，以减少在公共awaitPromise情况下的转换次数。</li> <li>如果传递给 await 的值已经是一个 Promise，那么这种优化避免了再次创建 Promise 包装器，在这种情况下，我们从最少三个 microtick 到只有一个 microtick。</li></ul> <h3 id="详细过程"><a href="#详细过程" class="header-anchor">#</a> 详细过程：</h3> <p>73以下版本</p> <ul><li><p>首先，打印script start，调用async1()时，返回一个Promise，所以打印出来async2 end。</p></li> <li><p>每个 await，会新产生一个promise,但这个过程本身是异步的，所以该await后面不会立即调用。</p></li> <li><p>继续执行同步代码，打印Promise和script end，将then函数放入微任务队列中等待执行。</p></li> <li><p>同步执行完成之后，检查微任务队列是否为null，然后按照先入先出规则，依次执行。</p></li> <li><p>然后先执行打印promise1,此时then的回调函数返回undefinde，此时又有then的链式调用，又放入*微任务队列中，再次打印promise2。</p></li> <li><p>再回到await的位置执行返回的 Promise 的 resolve 函数，这又会把 resolve 丢到微任务队列中，打印async1 end。</p></li> <li><p>当微任务队列为空时，执行宏任务,打印setTimeout。
谷歌（金丝雀73版本）</p></li> <li><p>如果传递给 await 的值已经是一个 Promise，那么这种优化避免了再次创建 Promise 包装器，在这种情况下，我们从最少三个 microtick 到只有一个 microtick。</p></li> <li><p>引擎不再需要为 await 创造 throwaway Promise - 在绝大部分时间。</p></li> <li><p>现在 promise 指向了同一个 Promise，所以这个步骤什么也不需要做。然后引擎继续像以前一样，创建 throwaway Promise，安排 PromiseReactionJob 在 microtask 队列的下一个 tick 上恢复异步函数，暂停执行该函数，然后返回给调用者。
具体详情查看<a href="https://v8.js.cn/blog/fast-async/" target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p></li></ul> <h2 id="nodejs的event-loop"><a href="#nodejs的event-loop" class="header-anchor">#</a> NodeJS的Event Loop</h2> <p>Node中的Event Loop是基于libuv实现的，而libuv是 Node 的新跨平台抽象层，libuv使用异步，事件驱动的编程方式，核心是提供i/o的事件循环和异步回调。libuv的API包含有时间，非阻塞的网络，异步文件操作，子进程等等。 Event Loop就是在libuv中实现的。</p> <ul><li>Node的Event loop一共分为6个阶段，每个细节具体如下：</li> <li>timers: 执行setTimeout和setInterval中到期的callback。</li> <li>pending callback: 上一轮循环中少数的callback会放在这一阶段执行。
idle, prepare: 仅在内部使用。</li> <li>poll: 最重要的阶段，执行pending callback，在适当的情况下回阻塞在这个阶段。</li> <li>check: 执行setImmediate(setImmediate()是将事件插入到事件队列尾部，主线程和事件队列的函数执行完成之后立即执行setImmediate指定的回调函数)的callback。
close callbacks: 执行close事件的callback，例如socket.on('close'[,fn])或者http.server.on('close, fn)。</li></ul> <p>具体细节如下：</p> <h3 id="timers"><a href="#timers" class="header-anchor">#</a> timers</h3> <p>执行setTimeout和setInterval中到期的callback，执行这两者回调需要设置一个毫秒数，理论上来说，应该是时间一到就立即执行callback回调，但是由于system的调度可能会延时，达不到预期时间。</p> <p>以下是官网文档解释的例子：</p> <div class="language-Javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">someAsyncOperation</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Assume this takes 95ms to complete</span>
  fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'/path/to/file'</span><span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> timeoutScheduled <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> delay <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> timeoutScheduled<span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>delay<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">ms have passed since I was scheduled</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// do someAsyncOperation which takes 95 ms to complete</span>
<span class="token function">someAsyncOperation</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> startCallback <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// do something that will take 10ms...</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startCallback <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// do nothing</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>当进入事件循环时，它有一个空队列（fs.readFile()尚未完成），因此定时器将等待剩余毫秒数，当到达95ms时，fs.readFile()完成读取文件并且其完成需要10毫秒的回调被添加到轮询队列并执行。</p> <p>当回调结束时，队列中不再有回调，因此事件循环将看到已达到最快定时器的阈值，然后回到timers阶段以执行定时器的回调。</p> <p>在此示例中，您将看到正在调度的计时器与正在执行的回调之间的总延迟将为105毫秒。</p> <p><strong>以下是我测试时间：</strong></p> <h3 id="pending-callbacks"><a href="#pending-callbacks" class="header-anchor">#</a> pending callbacks</h3> <p>此阶段执行某些系统操作（例如TCP错误类型）的回调。 例如，如果TCP socket ECONNREFUSED在尝试connect时receives，则某些* nix系统希望等待报告错误。 这将在pending callbacks阶段执行。</p> <h3 id="poll"><a href="#poll" class="header-anchor">#</a> poll</h3> <p>该poll阶段有两个主要功能：</p> <ul><li><p>执行I/O回调。</p></li> <li><p>处理轮询队列中的事件。</p></li></ul> <p>当事件循环进入poll阶段并且在timers中没有可以执行定时器时，将发生以下两种情况之一</p> <p>如果poll队列不为空，则事件循环将遍历其同步执行它们的callback队列，直到队列为空，或者达到system-dependent（系统相关限制）。</p> <ul><li><p>如果poll队列为空，则会发生以下两种情况之一</p></li> <li><p>如果有setImmediate()回调需要执行，则会立即停止执行poll阶段并进入执行check阶段以执行回调。</p></li> <li><p>如果没有setImmediate()回到需要执行，poll阶段将等待callback被添加到队列中，然后立即执行。</p></li></ul> <p>当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。</p> <h3 id="check"><a href="#check" class="header-anchor">#</a> check</h3> <p>此阶段允许人员在poll阶段完成后立即执行回调。</p> <p>如果poll阶段闲置并且script已排队setImmediate()，则事件循环到达check阶段执行而不是继续等待。</p> <p>setImmediate()实际上是一个特殊的计时器，它在事件循环的一个单独阶段运行。它使用libuv API来调度在poll阶段完成后执行的回调。</p> <p>通常，当代码被执行时，事件循环最终将达到poll阶段，它将等待传入连接，请求等。</p> <p>但是，如果已经调度了回调setImmediate()，并且轮询阶段变为空闲，则它将结束并且到达check阶段，而不是等待poll事件。</p> <div class="language-Javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'start'</span><span class="token punctuation">)</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timer1'</span><span class="token punctuation">)</span>
  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timer2'</span><span class="token punctuation">)</span>
  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise3'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">)</span>
</code></pre></div><p>如果node版本为v11.x， 其结果与浏览器一致。</p> <div class="language-Javascript extra-class"><pre class="language-javascript"><code>start
end
promise3
timer1
promise1
timer2
promise2
</code></pre></div><p>具体详情可以查看《又被node的eventloop坑了，这次是node的锅》。</p> <p>如果v10版本上述结果存在两种情况：</p> <ul><li>如果time2定时器已经在执行队列中了</li></ul> <div class="language-Javascript extra-class"><pre class="language-javascript"><code>start
end
promise3
timer1
timer2
promise1
promise2
</code></pre></div><ul><li>如果time2定时器没有在执行对列中，执行结果为</li></ul> <div class="language-Javascript extra-class"><pre class="language-javascript"><code>start
end
promise3
timer1
promise1
timer2
promise2
</code></pre></div><p>具体情况可以参考poll阶段的两种情况。
从下图可能更好理解：</p> <h2 id="setimmediate-的settimeout-的区别"><a href="#setimmediate-的settimeout-的区别" class="header-anchor">#</a> setImmediate() 的setTimeout()的区别</h2> <p><strong>setImmediate和setTimeout()是相似的，但根据它们被调用的时间以不同的方式表现。</strong></p> <ul><li><p>setImmediate()设计用于在当前poll阶段完成后check阶段执行脚本 。</p></li> <li><p>setTimeout() 安排在经过最小（ms）后运行的脚本，在timers阶段执行。</p></li></ul> <h3 id="举个例子-2"><a href="#举个例子-2" class="header-anchor">#</a> 举个例子</h3> <div class="language-Javascript extra-class"><pre class="language-javascript"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>执行定时器的顺序将根据调用它们的上下文而有所不同。 如果从主模块中调用两者，那么时间将受到进程性能的限制。</p> <p>其结果也不一致</p> <p>如果在I / O周期内移动两个调用，则始终首先执行立即回调：</p> <div class="language-Javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>__filename<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'immediate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>其结果可以确定一定是immediate =&gt; timeout。</p> <p>主要原因是在I/O阶段读取文件后，事件循环会先进入poll阶段，发现有setImmediate需要执行，会立即进入check阶段执行setImmediate的回调。</p> <p>然后再进入timers阶段，执行setTimeout，打印timeout。</p> <div class="language-Javascript extra-class"><pre class="language-javascript"><code>┌───────────────────────────┐
┌─<span class="token operator">&gt;</span>│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle<span class="token punctuation">,</span> prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming<span class="token operator">:</span>   │
│  │           poll            │<span class="token operator">&lt;</span>─────┤  connections<span class="token punctuation">,</span> │
│  └─────────────┬─────────────┘      │   data<span class="token punctuation">,</span> etc<span class="token punctuation">.</span>  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘

</code></pre></div><h2 id="process-nexttick"><a href="#process-nexttick" class="header-anchor">#</a> Process.nextTick()</h2> <p>process.nextTick()虽然它是异步API的一部分，但未在图中显示。这是因为process.nextTick()从技术上讲，它不是事件循环的一部分。</p> <ul><li>process.nextTick()方法将 callback 添加到next tick队列。 一旦当前事件轮询队列的任务全部完成，在next tick队列中的所有callbacks会被依次调用。</li></ul> <p>换种理解方式：</p> <ul><li>当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。</li></ul> <h3 id="例子"><a href="#例子" class="header-anchor">#</a> 例子</h3> <div class="language-Javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> bar<span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setImmediate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token function">someAsyncApiCall</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">someAsyncApiCall</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">,</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
bar <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre></div><p>在NodeV10中上述代码执行可能有两种答案，一种为：</p> <div class="language-Javascript extra-class"><pre class="language-javascript"><code>bar <span class="token number">1</span>
setTimeout
setImmediate
</code></pre></div><p>另一种为：</p> <div class="language-Javascript extra-class"><pre class="language-javascript"><code>bar <span class="token number">1</span>
bar <span class="token number">1</span>
setImmediate
setTimeout
</code></pre></div><p>无论哪种，始终都是先执行process.nextTick(callback)，打印bar 1。</p> <h2 id="comment-area"><a href="#comment-area" class="header-anchor">#</a> Comment area</h2> <!----></div> <!----> <hr> <!----></div> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#前言" title="前言">前言</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#为啥要弄懂event-loop" title="为啥要弄懂Event Loop">为啥要弄懂Event Loop</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#栈、队列的基本概念" title="栈、队列的基本概念">栈、队列的基本概念</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#栈-stack" title="栈（Stack）">栈（Stack）</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#队列-queue" title="队列（Queue）">队列（Queue）</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#event-loop" title="Event Loop">Event Loop</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#宏任务" title="（宏任务）">（宏任务）</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#微任务" title="（微任务）">（微任务）</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#浏览器中的event-loop" title="浏览器中的Event Loop">浏览器中的Event Loop</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#js调用栈" title="JS调用栈">JS调用栈</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#同步任务和异步任务" title="同步任务和异步任务">同步任务和异步任务</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#事件循环的进程模型" title="事件循环的进程模型">事件循环的进程模型</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#执行进入microtask检查点时-用户代理会执行以下步骤" title="执行进入microtask检查点时，用户代理会执行以下步骤：">执行进入microtask检查点时，用户代理会执行以下步骤：</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#举个例子" title="举个例子">举个例子</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#第一次执行" title="第一次执行：">第一次执行：</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#第二次执行" title="第二次执行：">第二次执行：</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#第三次执行" title="第三次执行：">第三次执行：</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#第四次执行" title="第四次执行：">第四次执行：</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#再举个例子" title="再举个例子">再举个例子</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#关于73以下版本和73版本的区别" title="关于73以下版本和73版本的区别">关于73以下版本和73版本的区别</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#在老版本中" title="在老版本中">在老版本中</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#引用贺老师知乎上的一个例子" title="引用贺老师知乎上的一个例子">引用贺老师知乎上的一个例子</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#谷歌-金丝雀-73版本中" title="谷歌（金丝雀）73版本中">谷歌（金丝雀）73版本中</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#详细过程" title="详细过程：">详细过程：</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#nodejs的event-loop" title="NodeJS的Event Loop">NodeJS的Event Loop</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#timers" title="timers">timers</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#pending-callbacks" title="pending callbacks">pending callbacks</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#poll" title="poll">poll</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#check" title="check">check</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#setimmediate-的settimeout-的区别" title="setImmediate() 的setTimeout()的区别">setImmediate() 的setTimeout()的区别</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#举个例子-2" title="举个例子">举个例子</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#process-nexttick" title="Process.nextTick()">Process.nextTick()</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#例子" title="例子">例子</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#comment-area" title="Comment area">Comment area</a></div></div></div></div> <footer class="footer" data-v-582f9766><div class="footer-left-wrap" data-v-582f9766><ul class="contact" data-v-582f9766><li class="contact-item" data-v-582f9766><a href="https://github.com/dsh225" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-582f9766><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-582f9766><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-582f9766></path></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-582f9766><ul class="copyright" data-v-582f9766><li class="copyright-item" data-v-582f9766><a href="https://choosealicense.com/licenses/mit/" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-582f9766>MIT Licensed | Copyright © 2018-present</a></li></ul></div></footer></div><div class="global-ui"><!----><canvas id="vuepress-canvas-cursor"></canvas></div></div>
    <script src="/my-blog/assets/js/app.6d65ba20.js" defer></script><script src="/my-blog/assets/js/4.83dd6824.js" defer></script><script src="/my-blog/assets/js/1.f69694c8.js" defer></script><script src="/my-blog/assets/js/40.09d36728.js" defer></script>
  </body>
</html>
